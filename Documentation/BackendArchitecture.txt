Архитектура серверной части приложения "RunQuest"

Серверная часть приложения "RunQuest" построена на базе фреймворка Django с использованием Django REST framework для реализации API и GeoDjango для работы с геоданными. Проект структурирован в виде Django-приложения `core`, которое содержит основную логику.

Основные компоненты серверной части:

1.  **Модели (Models):** Определены в файле `backend/core/models.py`. Модели представляют структуру данных в базе данных (PostgreSQL с расширением PostGIS). Ключевые модели включают:
    *   `User` (встроенная модель Django): Управление пользователями.
    *   `Profile`: Дополнительная информация о пользователе (аватар, уровень, опыт, настройки приватности).
    *   `Run`: Информация об индивидуальных пробежках пользователя, включая геометрию маршрута (`route_data` - LineStringField).
    *   `Achievement`: Определение различных достижений (по дистанции, длительности, количеству пробежек, прохождению трассы и т.д.).
    *   `UserAchievement`: Связь между пользователем и полученным достижением, статус выполнения.
    *   `Challenge`: Определение челленджей (по целям дистанции, длительности, количеству пробежек, прохождению трассы и т.д.).
    *   `UserChallenge`: Связь между пользователем и его участием в челлендже, прогресс и статус выполнения.
    *   `RaceTrack`: Определение трасс для гонок на время, включая геометрию маршрута (`route_definition`).
    *   `UserRaceAttempt`: Попытка пользователя пройти трассу гонки, включая фактический маршрут и время.
    *   `Friend`: Управление отношениями дружбы между пользователями.
    *   `ActivityItem`: Элементы ленты активности (завершение пробежки, получение достижения, запрос в друзья и т.д.).
    *   `ActivityComment`: Комментарии к элементам ленты активности.
    *   `JointRunInvitation`: Приглашения на совместные пробежки.
    *   `PlannedJointRun`: Запланированные совместные пробежки после принятия приглашения.
    *   `Block`: Блокировка пользователей.
    *   `DeviceToken`: Токены устройств для push-уведомлений.

2.  **Сериализаторы (Serializers):** Определены в файле `backend/core/serializers.py`. Сериализаторы преобразуют данные из моделей в формат JSON (и обратно) для передачи через API. Используются `rest_framework.serializers.ModelSerializer` и `rest_framework_gis.serializers.GeoFeatureModelSerializer` для работы с геоданными в формате GeoJSON.

3.  **Представления (Views):** Определены в файле `backend/core/views.py`. Представления обрабатывают входящие HTTP-запросы и возвращают HTTP-ответы. Используются ViewSets из Django REST framework для создания API-эндпоинтов (CRUD-операции) для моделей. Некоторые представления содержат дополнительную логику, например, фильтрацию данных в зависимости от приватности профиля пользователя или расчет статистики.

4.  **URL-маршруты (URLs):** Определены в файле `backend/core/urls.py`. URL-маршруты связывают URL-адреса с соответствующими представлениями. Используется `DefaultRouter` для автоматической генерации URL-адресов для ViewSets.

5.  **Сигналы (Signals):** Определены в файле `backend/core/signals.py`. Сигналы позволяют выполнять определенный код в ответ на события в моделях (например, после сохранения объекта). В проекте используются сигналы для:
    *   Автоматического создания профиля и записи активности при регистрации нового пользователя.
    *   Автоматического сохранения профиля при сохранении объекта User.
    *   Проверки и начисления достижений после завершения пробежки (`check_run_achievements`).
    *   Проверки и начисления достижений и челленджей после завершения попытки в гонке (`check_race_attempt_achievements_and_challenges`), включая логику сопоставления маршрутов с использованием геопространственных функций.

**Взаимодействие компонентов:**

*   Клиентская часть взаимодействует с серверной через API-эндпоинты, определенные в `views.py` и настроенные в `urls.py`. Запросы обрабатываются соответствующими ViewSet или APIView.
*   Представления используют Сериализаторы для валидации входящих данных и форматирования исходящих данных.
*   Представления взаимодействуют с Моделями для получения, создания, обновления и удаления данных в базе данных.
*   Модели могут инициировать Сигналы (например, `post_save` после сохранения объекта), которые затем запускают соответствующие функции-обработчики сигналов для выполнения дополнительной логики (например, начисление достижений).
*   GeoDjango используется на уровне Моделей (LineStringField) и в логике Сигналов и Представлений (например, при расчете совпадения маршрутов или фильтрации по геоданным) для работы с пространственными данными.

**Функциональность серверной части:**

Реализованная функциональность включает:

*   Регистрация и аутентификация пользователей.
*   Управление профилями пользователей (просмотр/редактирование собственного, просмотр чужих с учетом приватности).
*   Запись, хранение и предоставление данных о пробежках (включая маршрут).
*   Определение и управление достижениями и челленджами.
*   Автоматическое начисление достижений и обновление прогресса челленджей на основе данных пробежек и гонок.
*   Определение и управление трассами для гонок на время.
*   Запись и обработка попыток пользователей в гонках, расчет XP за гонку.
*   Ведение таблицы лидеров гонок.
*   Управление отношениями дружбы (отправка/принятие/отклонение запросов, список друзей).
*   Блокировка пользователей.
*   Формирование и предоставление ленты активности пользователя.
*   Добавление и просмотр комментариев к записям ленты активности.
*   Функциональность для совместных пробежек (приглашения, запланированные пробежки).
*   Хранение токенов устройств для потенциальной реализации push-уведомлений.
*   Поиск пользователей.

**Используемые инструменты и технологии:**

*   **Фреймворк:** Django
*   **API:** Django REST framework
*   **Геоданные:** GeoDjango, PostGIS (расширение PostgreSQL)
*   **Язык программирования:** Python
*   **База данных:** PostgreSQL
*   **Библиотеки геообработки:** GDAL, GEOS, PROJ (требуют правильной настройки в ОС/окружении)

Серверная часть спроектирована с учетом модульности, используя стандартные подходы Django и Django REST framework. Модели определяют данные, сериализаторы - формат данных для API, представления - логику обработки запросов, URL-ы - маршрутизацию, а сигналы - реакцию на события в моделях, что позволяет гибко расширять функциональность. 