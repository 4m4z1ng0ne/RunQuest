### Обзор серверной части RunQuest (Бэкенд на Django REST Framework)

Серверная часть приложения RunQuest построена на фреймворке Django с использованием расширения Django REST Framework (DRF) для создания Web API. В качестве базы данных используется PostgreSQL с расширением PostGIS для работы с геопространственными данными.

#### Архитектура:

Бэкенд следует архитектурному шаблону Model-View-Controller (MVC), который в Django реализуется как Model-View-Template (MVT), хотя для API-центричного приложения с DRF это больше похоже на Model-View-Serializer.

*   **Models:** Определяют структуру данных и взаимодействие с базой данных (в `core/models.py`). Используется Django ORM и GeoDjango для геопространственных типов полей.
*   **Views:** Обрабатывают запросы, взаимодействуют с моделями и сериализаторами, возвращают ответы (в `core/views.py`). Используются ViewSet'ы из DRF для предоставления CRUD операций и кастомных действий через API.
*   **Serializers:** Преобразуют данные моделей в формат JSON (и обратно) для передачи по API (в `core/serializers.py`). Используются сериализаторы DRF и DRF-GIS для геопространственных данных.
*   **URLs:** Определяют маршруты API и связывают их с View'ами (в `backend/urls.py` и `core/urls.py`). Используются роутеры DRF и DRF-Nested-Routers для автоматической генерации URL для ViewSet'ов.

#### Ключевые компоненты и функциональность:

1.  **Аутентификация (JWT):**
    *   Используется `djangorestframework-simplejwt` для аутентификации на основе JSON Web Tokens.
    *   Эндпоинты `/api/token/` для получения пары access/refresh токенов и `/api/token/refresh/` для обновления access токена.
    *   Доступ к защищенным эндпоинтам требует передачи access токена в заголовке `Authorization: Bearer <token>`.

2.  **Управление пользователями и профилями:**
    *   Стандартная модель `User` из `django.contrib.auth` для аутентификации.
    *   Модель `Profile` (`core/models.py`) для хранения дополнительной информации о пользователе (аватар, уровень, опыт).
    *   API `/api/register/` для регистрации новых пользователей (создает `User` и связанный `Profile`).
    *   API `/api/profile/` для получения и обновления профиля текущего пользователя.

3.  **Пробежки (`Run`):**
    *   Модель `Run` (`core/models.py`) хранит данные о пробежке (пользователь, время старта, дистанция, длительность, калории, маршрут).
    *   Геопространственное поле `route_data` (`gismodels.LineStringField`) для хранения маршрута в формате LineString.
    *   API `/api/runs/` (ViewSet) для создания, просмотра, обновления и удаления пробежек пользователя. Автоматически связывается с текущим пользователем.
    *   При создании пробежки начисляется опыт, обновляется уровень пользователя, проверяются достижения и прогресс челленджей, создается запись в ленте активности.

4.  **Геймификация (`Achievement`, `Challenge`, `UserAchievement`, `UserChallenge`):**
    *   Модели `Achievement` и `Challenge` (`core/models.py`) описывают достижения и челленджи.
    *   Модели `UserAchievement` и `UserChallenge` связывают пользователей с полученными достижениями и прогрессом по челленджам.
    *   API `/api/achievements/`, `/api/challenges/` (ReadOnly ViewSets) для просмотра доступных достижений и активных челленджей.
    *   API `/api/user-achievements/`, `/api/user-challenges/` (ReadOnly ViewSets) для просмотра достижений и челленджей текущего пользователя.
    *   Логика обновления прогресса и завершения челленджей интегрирована в `RunViewSet`.

5.  **Друзья (`Friend`):**
    *   Модель `Friend` (`core/models.py`) представляет собой связь между двумя пользователями со статусом (ожидает, принят, отклонен).
    *   API `/api/friends/` (ViewSet) для создания запросов в друзья. Автоматически устанавливает отправителя.
    *   Пользовательские действия `accept/`, `reject/` на эндпоинтах `/api/friends/{id}/` для обработки запросов.
    *   Пользовательские действия `my_friends/`, `pending_requests/` на эндпоинте `/api/friends/` для просмотра списка друзей и входящих запросов.
    *   Создание записей в ленте активности для отправки и принятия запросов.

6.  **Гонки (`RaceTrack`, `UserRaceAttempt`):**
    *   Модель `RaceTrack` (`core/models.py`) описывает предопределенные трассы гонок (название, дистанция, маршрут, рекорд).
    *   Геопространственное поле `route_definition` (`gismodels.LineStringField`) для маршрута трассы.
    *   Модель `UserRaceAttempt` (`core/models.py`) хранит данные о попытке пользователя пройти гонку (пользователь, трасса, длительность, статус, опыт, фактический маршрут, фактическая дистанция).
    *   Геопространственное поле `actual_route_data` (`gismodels.LineStringField`) для фактического маршрута.
    *   API `/api/race-tracks/` (ReadOnly ViewSet) для просмотра доступных трасс гонок.
    *   API `/api/user-race-attempts/` (ViewSet) для просмотра попыток гонок пользователя.
    *   Пользовательские действия `start_race/`, `finish_race/`, `cancel_race/` на эндпоинтах `/api/user-race-attempts/` и `/api/user-race-attempts/{id}/` для управления попытками гонок.
    *   При завершении гонки рассчитывается опыт, обновляется рекорд трассы, рассчитывается фактическая дистанция по `actual_route_data` с использованием PostGIS (`ST_Length`), создаются записи в ленте активности.
    *   API `/api/race-tracks/{track_id}/leaderboard/` (generics.ListAPIView) для просмотра лидерборда по конкретной трассе, показывающий лучшие результаты пользователей.
    *   API `/api/user-race-attempts/{id}/compare_route/` (пользовательское действие) для сравнения `actual_route_data` с `route_definition` трассы по проценту покрытия с использованием PostGIS (`ST_Intersection`, `ST_Length`).

7.  **Лента активности (`ActivityItem`):**
    *   Модель `ActivityItem` (`core/models.py`) хранит информацию о различных событиях в приложении (тип события, пользователь, время, ссылки на связанные объекты).
    *   API `/api/activity-feed/` (APIView) для получения ленты активности для текущего пользователя и его друзей.

8.  **Геопространственная функциональность (PostGIS/GeoDjango):**
    *   Хранение геометрии маршрутов (`LineStringField`).
    *   Использование геопространственных функций PostGIS через Django ORM для расчета длины маршрута (`.length`) и определения пересечения (`.intersection`).

9.  **Вспомогательные компоненты:**
    *   **Сериализаторы:** Определены для всех основных моделей для преобразования данных.
    *   **Роутеры:** Используются для автоматической маршрутизации ViewSet'ов.
    *   **Миграции:** Управляют изменениями схемы базы данных.
    *   **CORS:** Настроен для разрешения кросс-доменных запросов с фронтенда.
    *   **Swagger/ReDoc:** Интегрированы для автоматической документации API.
    *   **Пагинация и Фильтрация:** Добавлены для удобства работы с коллекциями данных.

Этот документ предоставляет высокоуровневое описание бэкенда. Более детальную информацию можно найти в исходном коде моделей, View'ов, сериализаторов и URL-конфигурации. 