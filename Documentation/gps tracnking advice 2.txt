Для реализации GPS-трекинга с отображением маршрута на OpenStreetMap через Django + Flutter нужно создать несколько компонентов:
Backend (Django)
1. Модели для хранения GPS-данных:
python# models.py
from django.db import models
from django.contrib.auth.models import User

class Route(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    start_time = models.DateTimeField()
    end_time = models.DateTimeField(null=True, blank=True)
    is_active = models.BooleanField(default=True)
    total_distance = models.FloatField(default=0.0)  # в метрах
    
class GPSPoint(models.Model):
    route = models.ForeignKey(Route, on_delete=models.CASCADE, related_name='points')
    latitude = models.DecimalField(max_digits=10, decimal_places=8)
    longitude = models.DecimalField(max_digits=11, decimal_places=8)
    altitude = models.FloatField(null=True, blank=True)
    accuracy = models.FloatField(null=True, blank=True)
    speed = models.FloatField(null=True, blank=True)
    timestamp = models.DateTimeField()
    
    class Meta:
        ordering = ['timestamp']
2. API для работы с GPS-данными:
python# serializers.py
from rest_framework import serializers
from .models import Route, GPSPoint

class GPSPointSerializer(serializers.ModelSerializer):
    class Meta:
        model = GPSPoint
        fields = '__all__'

class RouteSerializer(serializers.ModelSerializer):
    points = GPSPointSerializer(many=True, read_only=True)
    
    class Meta:
        model = Route
        fields = '__all__'

# views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.utils import timezone

class RouteViewSet(viewsets.ModelViewSet):
    serializer_class = RouteSerializer
    
    def get_queryset(self):
        return Route.objects.filter(user=self.request.user)
    
    @action(detail=False, methods=['post'])
    def start_tracking(self, request):
        route = Route.objects.create(
            user=request.user,
            name=request.data.get('name', f'Route {timezone.now()}'),
            start_time=timezone.now()
        )
        return Response(RouteSerializer(route).data)
    
    @action(detail=True, methods=['post'])
    def add_point(self, request, pk=None):
        route = self.get_object()
        point_data = request.data
        point_data['route'] = route.id
        
        serializer = GPSPointSerializer(data=point_data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'])
    def stop_tracking(self, request, pk=None):
        route = self.get_object()
        route.end_time = timezone.now()
        route.is_active = False
        route.save()
        return Response(RouteSerializer(route).data)
3. WebSocket для real-time обновлений (опционально):
python# consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class LocationConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.user_id = self.scope['user'].id
        self.group_name = f'location_{self.user_id}'
        
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        await self.accept()
    
    async def receive(self, text_data):
        data = json.loads(text_data)
        # Обработка полученной GPS-точки
        await self.channel_layer.group_send(
            self.group_name,
            {
                'type': 'location_update',
                'location': data
            }
        )
Frontend (Flutter)
1. Зависимости в pubspec.yaml:
yamldependencies:
  flutter_map: ^6.0.1
  geolocator: ^10.1.0
  http: ^1.1.0
  web_socket_channel: ^2.4.0
  latlong2: ^0.8.1
2. Сервис для работы с геолокацией:
dart// services/location_service.dart
import 'package:geolocator/geolocator.dart';

class LocationService {
  static Future<bool> checkPermissions() async {
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) return false;
    
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
    }
    
    return permission == LocationPermission.whileInUse || 
           permission == LocationPermission.always;
  }
  
  static Stream<Position> getPositionStream() {
    return Geolocator.getPositionStream(
      locationSettings: const LocationSettings(
        accuracy: LocationAccuracy.high,
        distanceFilter: 10, // обновление каждые 10 метров
      ),
    );
  }
}
3. API сервис:
dart// services/api_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class ApiService {
  static const String baseUrl = 'https://your-django-api.com/api';
  
  static Future<Map<String, dynamic>> startRoute(String name) async {
    final response = await http.post(
      Uri.parse('$baseUrl/routes/start_tracking/'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'name': name}),
    );
    return jsonDecode(response.body);
  }
  
  static Future<void> addGPSPoint({
    required int routeId,
    required double latitude,
    required double longitude,
    double? altitude,
    double? accuracy,
    double? speed,
    required DateTime timestamp,
  }) async {
    await http.post(
      Uri.parse('$baseUrl/routes/$routeId/add_point/'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'latitude': latitude,
        'longitude': longitude,
        'altitude': altitude,
        'accuracy': accuracy,
        'speed': speed,
        'timestamp': timestamp.toIso8601String(),
      }),
    );
  }
  
  static Future<Map<String, dynamic>> getRoute(int routeId) async {
    final response = await http.get(
      Uri.parse('$baseUrl/routes/$routeId/'),
    );
    return jsonDecode(response.body);
  }
}
4. Основной экран с картой:
dart// screens/tracking_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:geolocator/geolocator.dart';

class TrackingScreen extends StatefulWidget {
  @override
  _TrackingScreenState createState() => _TrackingScreenState();
}

class _TrackingScreenState extends State<TrackingScreen> {
  MapController mapController = MapController();
  List<LatLng> routePoints = [];
  bool isTracking = false;
  int? currentRouteId;
  StreamSubscription<Position>? positionStream;
  
  @override
  void initState() {
    super.initState();
    _initializeLocation();
  }
  
  Future<void> _initializeLocation() async {
    bool hasPermission = await LocationService.checkPermissions();
    if (!hasPermission) {
      // Показать диалог с просьбой предоставить разрешения
      return;
    }
  }
  
  Future<void> _startTracking() async {
    try {
      final route = await ApiService.startRoute('New Route');
      currentRouteId = route['id'];
      
      positionStream = LocationService.getPositionStream().listen((position) {
        _addPointToRoute(position);
      });
      
      setState(() {
        isTracking = true;
        routePoints.clear();
      });
    } catch (e) {
      print('Error starting tracking: $e');
    }
  }
  
  Future<void> _addPointToRoute(Position position) async {
    if (currentRouteId == null) return;
    
    final point = LatLng(position.latitude, position.longitude);
    
    setState(() {
      routePoints.add(point);
    });
    
    // Центрировать карту на текущей позиции
    mapController.move(point, 15.0);
    
    // Отправить точку на сервер
    try {
      await ApiService.addGPSPoint(
        routeId: currentRouteId!,
        latitude: position.latitude,
        longitude: position.longitude,
        altitude: position.altitude,
        accuracy: position.accuracy,
        speed: position.speed,
        timestamp: DateTime.fromMillisecondsSinceEpoch(
          position.timestamp?.millisecondsSinceEpoch ?? 
          DateTime.now().millisecondsSinceEpoch
        ),
      );
    } catch (e) {
      print('Error adding point: $e');
    }
  }
  
  void _stopTracking() {
    positionStream?.cancel();
    setState(() {
      isTracking = false;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GPS Tracker')),
      body: Stack(
        children: [
          FlutterMap(
            mapController: mapController,
            options: MapOptions(
              center: LatLng(55.7558, 37.6176), // Москва по умолчанию
              zoom: 13.0,
            ),
            children: [
              TileLayer(
                urlTemplate: 
                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                userAgentPackageName: 'com.example.gps_tracker',
              ),
              if (routePoints.isNotEmpty)
                PolylineLayer(
                  polylines: [
                    Polyline(
                      points: routePoints,
                      strokeWidth: 4.0,
                      color: Colors.blue,
                    ),
                  ],
                ),
              if (routePoints.isNotEmpty)
                MarkerLayer(
                  markers: [
                    // Начальная точка
                    Marker(
                      point: routePoints.first,
                      builder: (ctx) => Icon(
                        Icons.play_arrow,
                        color: Colors.green,
                        size: 30,
                      ),
                    ),
                    // Текущая позиция
                    if (routePoints.length > 1)
                      Marker(
                        point: routePoints.last,
                        builder: (ctx) => Icon(
                          Icons.my_location,
                          color: Colors.red,
                          size: 30,
                        ),
                      ),
                  ],
                ),
            ],
          ),
          Positioned(
            bottom: 30,
            left: 20,
            right: 20,
            child: ElevatedButton(
              onPressed: isTracking ? _stopTracking : _startTracking,
              child: Text(isTracking ? 'Stop Tracking' : 'Start Tracking'),
              style: ElevatedButton.styleFrom(
                backgroundColor: isTracking ? Colors.red : Colors.green,
                padding: EdgeInsets.symmetric(vertical: 15),
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  @override
  void dispose() {
    positionStream?.cancel();
    super.dispose();
  }
}
Дополнительные возможности
1. Оптимизация батареи:

Использовать различные настройки точности в зависимости от скорости
Регулировать частоту обновлений GPS
Останавливать трекинг при неподвижности

2. Офлайн режим:

Кешировать GPS-точки локально
Синхронизировать при восстановлении соединения
Загружать тайлы карты для офлайн использования

3. Анализ маршрута:

Расчет общего расстояния и времени
Определение средней и максимальной скорости
Построение высотного профиля

Этот подход обеспечивает надежное GPS-трекинг приложение с real-time отображением маршрута на OpenStreetMap.